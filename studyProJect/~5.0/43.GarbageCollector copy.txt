CLR 의 자동 메모리 관리 (AMM) 의 중심이 되는게 가비지컬렉션
GC :가비지 컬렉션을 담당함 /쓰레기(더이상 사용하지 않는 객체) 를 수거함


Object A = new Object; 객체를 만들면 힙에 A 가 필요한 만큼의 메모리가 할당됨

if(true)
{
    object a = new object();
}
가 a 는 스택 메모리에 있다가  } 를 만나며 스택에서 지워짐
그럼 힙에 남아있는 A 는 더이상 그어디에서도 접근할수 없는 코드가 되어 가비지 컬렉터가 지워버림

루트 : a 처럼 할당된 메모리의 위치를 참조하는 객체
.net 이 실행되면 JIT 가 루트 목록을 만들고 CLR 이 이 루트목록을 관리하며 상태를 갱신  이 갱신된 루트목록을 이용하여 가비지컬렉터가 쓰레기를 수집

가비지컬렉터의 루트목록관리
1. 가비지컬렉터는 모든 객체가 쓰레기라고 가정함
2. 루트목록을 순회하며 각루트가 참조하고있는 힙객체와의 관계여부 조사 루트가참조하는 힙이 또다른 힙을 참조한다면 이역시 루트 관계가 있다고판단
3. 이때 어떤 루트와도 관계없는 힙의 객체를 쓰레기로간주
4. 쓰레기 객체를 지워버리고 메모리 빈공간으로 만듬
5. 루트목록 조사가 끝나면 다시 힙을 순회하면서 비어있는 공간을 이동시켜 채워넣음

세대
가비지 컬렉터는 세대로 메모리를 관리한다
0세대 : 가장처음 등장한 메모리 집합
1세대 : 가비지컬렉터로부터1회 살아남은 0세대들이 포함되는 집합
2세대 : 가비지컬렉터로부터2회 살아남은 1세대들이 포함되는 집합

각세대의 메모리 임계치의 따라 가비지 컬렉션이 수행되고 가비지 컬렉션이 반복하며 0>1>2순으로 이동함
2세대에서는 3세대로 이동하지않고 2세대가 가득차면 2세대를 검사하는게아니라 0과 1세대에대해서 가비지컬렉션을 수행함
(2세대 가비지컬렉션 : 전체 가비지컬렉션 (Full Garbage Collection) 이라고도 부름)

세대구별을 하는 이유는 가비지컬렉터로부터 오래 살아남은 메모리일수록 더 오래 살아남을 확률이높기때문에
가비지컬렉터의 관심대상에서 멀어짐
즉 새로 생긴 메모리를 주로 검사하고 오래된 메모리는 관심을 덜줌

0세대가 가득차면 0세대만검사
1세대가 가득차면 0과 1세대만검사
2세대가 가득차면 (가비지컬렉터가 온힘을다하기위해?) "프로그램의 동작을 멈추고" FGC 전체를 검사한다. << 이때문에 GC 관리를 잘해야한다



가비지 컬렉터를 고려한 효율적 코드작성 지침
1. 객체 할당을 적당히한다.
너무 많읜 수의객체는 관리되는 힙의 메모리 포화를 초래하고 가비지컬렉터를 부른다

2. 너무큰 객체를 할당하지않는다
객체의 크기가 커도 가비지 메모리가 빠르게 차오르게되 가비지컬렉터를 자주 촉발한다

3. 너무 복잡한 참조를 만들지않는다
가비지 컬렉터를 제외하더라도 가독성 면에서 좋지않지만
참조 관계가 많은 객체는 가비지 컬렉션 이후에도 살아남기때문에 메모리 복사 과정에서 객체를 구성하는 필드 의 참조관계를 조사해 메모리 주소를 전부 수정해야함

4. 루트를 너무 많이 만들지않는다.
가비지 컬렉터는 루트를 돌며 쓰레기를 찾는데 루트 목록이 작아지면 가비지컬렉터의 검사 수행 횟수가 줄어들어 더빠른 일처리를 할수있다.



